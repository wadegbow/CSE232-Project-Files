#include <iostream>
using std::fixed;
#include <iomanip>
using std::setprecision;
#include <sstream>
using std::ostringstream;
#include <cmath>
using std::nan;
#include <algorithm>
using std::copy;

#include "polygon.h"

RegularPolygon::RegularPolygon(long n, Point pt) : n_(n), p_(pt),
s_(nan("")), a_(nan("")), r_(nan("")) {};

// getters
double RegularPolygon::get_a() {return a_;};
double RegularPolygon::get_r() {return r_;};
double RegularPolygon::get_s() {return s_;};
long RegularPolygon::get_n() {return n_;};

//setters
//setters check for a positive parameter then set each member
//they do nothing if the parameter is not positive
void RegularPolygon::set_a(double a) {
  if (a > 0){
    a_ = a; //apothem
    r_ = a/(cos(M_PI/n_));
    s_ = 2*sin(M_PI/n_)*r_;
  } else {
    return;
  }
};
void RegularPolygon::set_r(double r) {
  if (r > 0) {
    r_ = r; //circumradius
    s_ = 2*sin(M_PI/n_)*r_;
    a_ = cos(M_PI/n_)*r_;
  } else {
    return;
  }
};
void RegularPolygon::set_s(double s) {
  if (s > 0){
    s_ = s; //side length
    r_ = s/(2*sin(M_PI/n_));
    a_ = cos(M_PI/n_)*r_;
  } else {
    return;
  }
};

//checks that r,s and a are not nan then returns the area
double RegularPolygon::get_area() {
  if (!isnan(r_) && !isnan(s_) && !isnan(a_))
    return .5*(n_*s_*a_);
  else
    return nan("");
};

//function adds the double parameter to the member var
//of the same letter
void RegularPolygon::add(double number,char letter) {
  double temp;

  if (letter == 'a') {
    temp = a_ + number;
    this->set_a(temp);
  }
  if (letter == 's') {
    temp = s_ + number;
    this->set_s(temp);
  }
  if (letter == 'r') {
    temp = r_ + number;
    this->set_r(temp);
  }

};

//function multiplies the double parameter to the member var
//of the same letter
void RegularPolygon::mult(double number, char letter) {
  double temp;

  if (letter == 'a') {
    temp = a_ * number;
    this->set_a(temp);
  }
  if (letter == 's') {
    temp = s_ * number;
    this->set_s(temp);
  }
  if (letter == 'r') {
    temp = r_ * number;
    this->set_r(temp);
  }
};

//generates the points for your polygon
vector<Point> RegularPolygon::generate_points() {
  double vertex_x, vertex_y, exteriorAngle = (2*M_PI)/n_;
  vector<Point> points;

  for (int i = 0; i <= n_-1; i++) {
    vertex_x = p_.x_ + r_ * cos(i * exteriorAngle);
    vertex_y = p_.y_ + r_ * sin(i * exteriorAngle);
    points.push_back(Point(vertex_x, vertex_y));
  }

  return points;
};

//friend function that returns an ostream containing formated variable values
ostream & operator<<(ostream &out, RegularPolygon& poly){
    out.precision(5);
    out << "#sides=" << poly.get_n() << ", s=" << poly.get_s() << ", apothem="
    << poly.get_a() << ", circumradius=" << poly.get_r();

    return out;
}

//returns a formatted string of the points generated by generate_points
string vector_to_string(vector<Point>& pt_vector) {
  ostringstream out;
  //set fixed and precision of 4
  out << fixed << setprecision(4);

  for (Point pt : pt_vector) {
    out << "(" << pt.x_ << "," << pt.y_ << "),";
  }

  string output = out.str();
  //remove comma
  output.pop_back();

  return output;
};
